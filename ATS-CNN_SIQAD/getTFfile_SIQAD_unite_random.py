# -*- coding:UTF-8 -*-

import os
import gzip
import numpy
from scipy import stats
import PIL.Image as Image
from tensorflow.python.platform import gfile
import matplotlib.pyplot as plt
import tensorflow as tf

DIR = 'J:/aaaaaaaaaaaaa' # the location of the database
DATABASE = 'SIQAD'
REF_PATH = DIR + '/' + DATABASE + '/references/'
DIS_PATH = DIR + '/' + DATABASE + '/'
MOS_PATH = DIR + '/' + DATABASE + '/SIQAD_IQA.txt'

DATA_DIR = 'F:/myfouraaaaaaaaa/data_SCI_unite_32_gm_random'  # The location of the TFrecord file

TRAIN_DATA_NUM = 16
TEST_DATA_NUM = 4
DISNUM_PER_IMAGE = 49
PATCH_SIZE = 32# 128
patch_num = 256
width_fixed = 640
height_fixed = 640


ORDER = numpy.random.permutation(TRAIN_DATA_NUM +TEST_DATA_NUM)   # Returns the number in shuffled order  # Randomly split the dataset


def _int64_feature(value):
    return tf.train.Feature(int64_list=tf.train.Int64List(value=[value]))


def _float_feature(value):
    return tf.train.Feature(float_list=tf.train.FloatList(value=[value]))


def _bytes_feature(value):
    return tf.train.Feature(bytes_list=tf.train.BytesList(value=[value]))


# Returns the gradient map of the canonical image
def gradient(img_resize, height, width):
    a = [[-1, 1], [-1, 1]]
    b = [[-1, -1], [1, 1]]
    window_h = numpy.array(a)/2
    window_v = numpy.array(b)/2

    gra_h = numpy.zeros([height, width])
    for i in range(0, height):
        for j in range(0, width):
            if (j == width-1) & (i == height-1):
                gra_h[i, j] = sum(sum(numpy.array([[img_resize[i, j], 0], [0, 0]])*window_h))
            elif j == width-1:
                gra_h[i, j] = sum(sum(numpy.array([[img_resize[i, j], 0], [img_resize[i+1, j], 0]])*window_h))
            elif i == height-1:
                gra_h[i, j] = sum(sum(numpy.array([[img_resize[i, j], img_resize[i, j+1]], [0, 0]])*window_h))
            else:
                gra_h[i, j] = sum(sum(numpy.array([[img_resize[i, j], img_resize[i, j+1]], [img_resize[i+1, j], img_resize[i+1, j+1]]])*window_h))
    gra_v = numpy.zeros([height, width])
    for i in range(0, height):
        for j in range(0, width):
            if (j == width-1) & (i == height-1):
                gra_v[i, j] = sum(sum(numpy.array([[img_resize[i, j], 0], [0,0]])*window_v))
            elif j == width-1:
                gra_v[i, j] = sum(sum(numpy.array([[img_resize[i, j], 0], [img_resize[i+1, j], 0]])*window_v))
            elif i == height-1:
                gra_v[i, j] = sum(sum(numpy.array([[img_resize[i, j], img_resize[i, j+1]], [0, 0]])*window_v))
            else:
                gra_v[i, j] = sum(sum(numpy.array([[img_resize[i, j], img_resize[i, j+1]], [img_resize[i+1, j], img_resize[i+1, j+1]]])*window_v))
    gra = abs(gra_h)+abs(gra_v)
    return gra


# Segment distorted images
def load_img_regroup(path, mos, width, height, gray_scale=False):
    patch_text = []
    patch_pic = []
    g_path = path[0:19] + 'gradientimg' + path[31:]  # Gradient images need to be generated by yourself
    index_path = path[0:19] + 'index_unite_32' + path[31:]  # The positions of the graphics area and the text area are obtained by VLSD method, and these positions are saved as images.
    mscn_path = path[0:19] + 'mscn' + path[31:]  # Self-generated MSCN images
    width = int(width)
    height = int(height)

    im_g = Image.open(g_path)
    im_g = im_g.resize((width, height), Image.ANTIALIAS)
    im_g = im_g.convert('L')
    im_g = numpy.asarray(im_g, dtype=numpy.uint8)

    im_ind = Image.open(index_path)
    im_ind = numpy.asarray(im_ind, dtype=numpy.uint8)

    im_mscn = Image.open(mscn_path)
    im_mscn = im_mscn.resize((width, height), Image.ANTIALIAS)
    im_mscn = im_mscn.convert('L')
    im_mscn = numpy.asarray(im_mscn, dtype=numpy.uint8)

    num_height = 640//PATCH_SIZE
    num_width = 640//PATCH_SIZE
    for i in range(0, num_height):
        i_ac = i * PATCH_SIZE
        for j in range(0, num_width):
            j_ac = j * PATCH_SIZE
            if im_ind[i, j] > 200:
                img_cut_g = im_g[i_ac: i_ac + PATCH_SIZE, j_ac: j_ac + PATCH_SIZE]
                patch_text.append(img_cut_g)
            elif im_ind[i, j] < 100:
                img_cut_mscn = im_mscn[i_ac: i_ac + PATCH_SIZE, j_ac: j_ac + PATCH_SIZE]
                patch_pic.append(img_cut_mscn)
    patch = [patch_text, patch_pic]
    patch = numpy.asarray(patch)
    # print(patch.shape)
    patch_re = patch.reshape([patch_num, PATCH_SIZE, PATCH_SIZE, 1])

    return patch_re, mos


def convert_to(x, y, filename, i):
    """Converts data to tfrecords.

    Args:
      :param x, y: list - [img1, img2, ...].
                    img: ndarray.
      :param name: str.
    """
    if not gfile.Exists(filename):
        print('Writing', filename)
        writer = tf.python_io.TFRecordWriter(filename)
        for index in range(DISNUM_PER_IMAGE):
            img_group = x[index]
            for i in range(128):
                img_one = img_group[i]
                img_two = img_group[i+128]
                img_c = numpy.concatenate([img_one[:, :, numpy.newaxis], img_two[:, :, numpy.newaxis]], axis=2)
                img_c = numpy.array(img_c)
                img = img_c.tostring()
                example = tf.train.Example(features=tf.train.Features(feature={
                    'img': _bytes_feature(img),
                    'label': _float_feature(y[index]),
                    # 'type_ref': _float_feature(z[index])
                }))
                writer.write(example.SerializeToString())

        writer.close()
            

# Read data from MOS file and convert to tfrecord file
def load_Image():
    text_file = open(MOS_PATH, "r")
    lines = text_file.readlines()
    text_file.close()
    print(len(lines))
    # read the image of distorted and the value of dmos
    dis_img_set = []
    mos_set = []
    Flag_set = []
    for line in lines:
        Readname = line.rstrip().split('\t', 6)  # (5.51, i01_01_1.bmp)  # Divide 6 times with ' ' as the boundary
        mos = Readname[4]
        name = Readname[3]
        width = Readname[5]
        height = Readname[6]

        # Convert to Examples and write the result to TFRecords.
        path = DIS_PATH + name.lower()
        # img_resize = numpy.asarray(load_img(path, gray_scale=False), dtype=numpy.uint8) ## ndarray(0,255)      Convert data to array
        img_resize, mos_regroup = load_img_regroup(path, float(mos), width_fixed, height_fixed, gray_scale=True)  # original image->(128, 128, 1)

        dis_img_set.append(img_resize)  # image data (980 ** 128 128 1)
        mos_set.append(mos_regroup)  # mos value of the image

    FRONT = 0
    BACK = DISNUM_PER_IMAGE
    # convert the data to tfrecord
    for i in range(TRAIN_DATA_NUM + TEST_DATA_NUM):
        img_num = [dis_img_set[j] for j in numpy.arange(FRONT,  BACK)]  # Separate the distorted images corresponding to the i-th image
        labels = [mos_set[j] for j in numpy.arange(FRONT,  BACK)]
        # type_ref = [Flag_set[j] for j in numpy.arange(FRONT,  BACK)]

        FRONT = BACK
        BACK = BACK + DISNUM_PER_IMAGE

        if not gfile.Exists(DATA_DIR):
            os.makedirs(DATA_DIR)
        filename = os.path.join(DATA_DIR, "image_" + str(i) + ".tfrecords")
        convert_to(img_num, labels, filename, i)





if __name__ == '__main__':
    print('data order: %s' % ORDER)
    load_Image()



# Convert image data to tfrecord file
